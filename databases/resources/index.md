> **Индекс** - механизм ускорения запросов в БД. 
> Можно представить его механизм работы как хэш-мапу. Нужно конкретно значение атрибута? - Прыгай сразу на конкретную позицию.
> Только работает он не строго как хэшмапа... Есть разные его виды...

* Пример создания индекса на жанр книги (может часто будем искать в электронной библиотеке)
```sql
CREATE INDEX [index_name]
ON [table_name] ([column_name], ...);

CREATE INDEX [book_genre_index]
ON books (genre);
```
* Вставка индексов часто требует сканирования всех нужных таблиц
* Не стоит добавлять индексы в таблицы, где очень часто происходит изменение данных
* Стоит их использовать там, где эти данные чаще читают (`WHERE`, `ORDER BY`, `GROUP BY`)
* Не стоит использовать на маленькие таблицы
* Полезные в `JOIN` операциях
* У индексов есть ограничение на размерность в разных СУБД
```sql
CREATE INDEX [book_genre_index]
ON books (genre, photo, rating);
-- если колонны genre + photo превышают, например, 1700 байт (MySQL) в общей сложности
-- .. то на rating не будет создан индекс
```
* Не стоить их использовать для столбцов, где много `NULL` данных
* Если создали композитный индекс, то ускорение запроса по обращению к одному из этой пачки индексов будет только для первого по порядку поля
```sql
CREATE INDEX [phone_charstx_idx]
ON [phones] (type, os, cpu)

-- ...
WHERE os = "Android" -- index won't work!

-- ...
WHERE type = "Sensor" -- index is working
```
# Index clusterisation
> В некоторых СУБД есть такая концепция кластеризации индексов...
## Clustered index
* Некоторый индекс по умолчанию, по которому определяется порядок данных в таблице. 
* В 1 таблице может быть только 1 кластеризованнный индекс.
* Данные в таблице хранятся в виде В-дерева, где нодами являются строки данных
* Полезно в случаях, когда на ключ часто будут применять `WHERE`, `ORDER BY`, `JOIN`
## Non-clustered index
* Отдельная структура, которая хранит индексы и соответствующие данные в отдельной таблице
* Требует явного задания
* В 1 таблице может быть несколько некластеризованных индексов
* Данные в таблице хранятся в виде В дерева, где нодами являются уже указатели на строки в оригинальной таблице
* Полезно в случаях, когда на не первичном ключе будут часто использовать `WHERE`
# Types
> Тип индексов насильно выбрать нельзя, можно лишь где-то как-то подсказывать (и то маловероятно, что оптимизатор запросов послушает) или выставить в настройках предпочтения.
## B-tree
* Наиболее распространённый тип индекса, по сути представляет собой сбалансированное дерево поиск O(log n)
* Поддерживает быстрый поиск, вставку, удаление и обновление данных
* Эффективен для операций сравнения (`=`, `>`, `<`, `BETWEEN`)
* Подходит для большинства сценариев
## Hash index
* Использует хэш-таблицу для поиска данных, ну и поиск О(1)
* Эффективен только для точного поиска (`=`)
* Не поддерживает диапазонные запросы или сортировку
* Применяется редко, обычно в специализированных СУБД
## Bitmap index
* Представляет каждого уникальное значение как битовую маску
* Используется для столбцов с небольшим количеством уникальных значений (например, пола или статуса)
* Эффективен для операций `AND`, `OR`, `NOT`
* Не подходит для часто изменяемых данных
## Full-text index
* Индексирует все слова в тексте, позволяя осуществлять поиск по ключевым словам в текстовых данных
* Поддерживает сложные запросы, такие как поиск по ключевым словам или фразам
* Применяется в СУБД, которые работают с большими текстовыми данными (например, PostgreSQL, MySQL)
## Spatial index
* Представляет собой структуры по типу R-дерева
* Используется для геоданных (например, координат)
* Поддерживает операции, такие как поиск ближайших объектов или пересечение областей
* Применяется в СУБД, работающих с геоданными (например, PostGIS для PostgreSQL)
## Composite index
* Индекс, созданный на несколько столбцов, Данные сортируются сначала по первому столбцу, потом по второму
* Эффективен для запросов, которые используют несколько условий в `WHERE`
* Порядок столбцов в индексе важен: запросы должны использовать префикс индекса