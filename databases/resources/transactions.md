> Это некоторый набор операций, который **выполняется атомарно**, т.е либо он выполнится, либо не выполнится, промежуточных состояний нет, только согласованные.
> Согласованное состояние - ошибка операции или всё успешно или что-то ещё...
# Основные операции
* `BEGIN` или `START TRANSACTION` для открытия блока транзакции
* `COMMIT` - для подтверждения транзакции
* `ROLLBACK` - для отмены транзакции
* `SAVEPOINT` - для установки "сохранения"
```sql
BEGIN;

INSERT INTO transactions (account, amount) VALUES ("account1", "-1000");

SAVEPOINT charged_off;

INSERT INTO transactions (account, amount) VALUES ("account2", "+1000");

ROLLBACK TO charged_off;
```
# Hidden mechanics
* Во многих СУБД **запросы на изменение данных автоматически обёртываются в транзакцию** с `AUTOCOMMIT`. Это также можно отключить, если вдруг надо
* В СУБД, очевидно, обычно есть таймаут на транзакцию, если забыть её закрыть, однако лучше закрывать вручную, т.к. данные будут заблокированы для других. Если закрыть соединение с БД, то транзакция может не закрыться...
* Транзакция **сначала применяется "виртуально"**, т.е. до `COMMIT` или `ROLLBACK` можно посмотреть результат выполнения транзакции, но не применять её к реальной БД
# Изоляция
> Уровень изоляции определяет то, на каком уровне транзакции могут взаимодействовать друг с другом или выполняться отдельно.

![](image-storage/Pasted%20image%2020250318232347.png)
## Аномалии транзакций
> Запоминать сильно не надо, их все можно считать как out-of-order. И да, это не все случаи...
### Dirty read
* Транзакция A читает баланс (1000) и увеличивает его на 100
- Транзакция B читает этот новый баланс (1100) и уменьшает его на 200
* Транзакция А отменяется
* Транзакция В возвращает баланс 900 (хотя должна была вернуть 1000 - 200 = 800)
* Транзакция В прочитала "виртуальный отпечаток" другой транзакции
### Lost update
* Транзакция A читает баланс (1000) и увеличивает его на 100
- Транзакция B читает тот же баланс (1000) и уменьшает его на 200
- Транзакция A записывает новый баланс: (1100)
- Транзакция B записывает новый баланс: (800)
* Обе транзакции  меняют один и тот же баланс
* В результате баланс становится 800, хотя ожидалось, что он будет 1000 + 100 - 200 = 900
* Обновление от транзакции A потерялось.
### Out-of-order
- Транзакция A меняет баланс с (10) на (1000)
- Транзакция B читает баланс (1000)
- Транзакция A откатывается (ROLLBACK), и баланс возвращается на (10)
* Транзакция В продолжает работать с балансом (1000)
* Получаем непредсказуемый результат
### Fuzzy read (Non-repeatable read)
* Транзакция A читает баланс (1000) и увеличивает его на 100
- Транзакция B читает этот же баланс (1000) и уменьшает его на 200
* Транзакция А выполняет логику со значением 1100
* Транзакции обе коммитятся.
* Транзакция А отработал бизнес логику со значением 1100, а транзакций В уже поменяла значение во время этой логики.
* Получается, что первая транзакция отработала на неактуальных данных.
### Phantom read
* Транзакция А читает всех юзеров и их счета
* Транзакция В добавляет нового юзера
* Фактически первая транзакция прочитала неактуальные данные
## Уровни изоляции транзакций
> Представленные уровни не все, их больше, и в разных СУБД работают по-разному.
> Уровни изоляции выставляются через `SET TRANSACTION ISOLATION LEVEL` или `SET SESSION TRANSACTION LEVEL` или `SET CHARASTERISTICS`и так далее.
### READ UNCOMMITTED 
> Позволяет транзакции видеть промежуточный результат другой (незавершённой) транзакции
* Вообще ни от чего не спасает
### READ COMMITTED 
> Позволяет транзакции читать только те данные, которые были закоммичены другими транзакциями.
* Если наша транзакция такая, а другая транзакция READ UNCOMMITED, то вторая транзакция может прочитать наши данные и изменить их. Т.е. такой уровень изоляции **спасает только от Dirty read**.
* Много где по умолчанию используется (PostgreSQL и MySQL точно)
### REPEATABLE READ
> Никто другой не может параллельно изменять или удалять данные, которые текущая транзакция уже прочитала, пока она не завершится.
* **Не всегда спасает от Phantom read**, т.к. после, например, чтения нашей транзакцией всей таблицы вторая транзакция может добавить данные. В итоге прочитаны неактуальные данные.
### SERIALIZABLE 
> Самая строгая изоляция, все используемые данные полностью блокируются на любые операции.
* Очевидно, что такая жёсткая блокировка сильно снижается перфоманс БД.
* Какие-то СУБД блокируют всю таблицу, какие-то только конкретные строки.
### CURSOR STABILITY
> Мало где используется, но если представить, что по транзакции бегает позиция/курсор, то блокируются только данные на этой конкретной строке запроса.
### READ STABILITY
> Другая транзакция не может менять читаемые нашей транзакией данные до нашего завершения.
### kind of SNAPSHOT ISOLATION
> Позволяет транзакциям видеть снимки данных БД до момента исполнения этими транзакциями чего-либо. Работает за счёт MVCC.
* Если 2 транзакции меняют одно и то же запись, то одна из них вернёт ошибку.
## MVCC
> **Multiversional Concurrency Control** - механизм concurent работы с данным БД, умеющий самостоятельно разрешать некоторые конфликты.
* Работает примерно как git
* Создаётся как snapshot данных БД до начала работы транзакции, так и виртуальная новая версия данных после завершения
* Естественно, у него есть сборщик мусора
* MVCC просто на основе меток времени изменения данных разрешает самостоятельно конфликт работы транзакций