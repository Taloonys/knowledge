---
id: golang
aliases:
  - project structure
tags:
  - code
  - languages
---

* компилируемый
* статическая строгая типизация
* error и panic вместо исключений
* интерфейсы вместо чистого ООП
* встроенное concurrency (горутины)
* есть garbage коллектор, работающий как **mark and sweep**
* go(cli) одновременно и сборщик, и система сборки, и утилита, и пакетный менеджер
* экспортируемые (публичные) сущности с Заглавной буквы, приватные - с маленькой буквы

# project structure
> [Подробное описание / стандарт](https://github.com/golang-standards/project-layout)

# tests
> Обычно тесты почемены суффиксом `*_test.go`
```bash
experimantal/ # имя проекта
	go.mod # конфигурационный файл проекта
	main.go
	foo/ # пакет foo
	    foo.go # файл с тестируемым кодом
	    foo_test.go # файл с тестами
```

```go
// Пример теста
import "testing"

func TestSumFunc(t *testing.T) {
	expected := 9
	if res := Sum(4, 5); res != expected {
		t.Errorf("expected -> %d <> got -> %d", expected, res)
	}
}

```
* `go test` работает только внутри пакета, из которого была вызвана, т.е. не надо вызывать её из корня проекта
* `go test ./...` - уже для теста из рута проекта, команда рекурсивно тестирует все пакеты
* иногда для тестов выделяют отдельный `package`, но так обычно не принято, тесты лежат в том же пакете в своих `_test` файлах 
# packages
* в начале каждого файла пишется принадлежность к пакету, `package main` есть
* импорт своего же пакета -> `<имя проекта>/<имя пакета>`, имя проекта указывается в `go.mod`
* имя пакета должно соответствовать имени директории, в которой он лежит
# gopath
* go ставит все необходимые ему файлы в `%GOPATH%`, по умолчанию это `$HOME/go`
* там же лежат исходники импортируемых либ, исходники go и т.п.
# fmt-пакет
* Та же логика, что и у printf
* Если выводить random-access контейнер несколько раз, то вывод всегда будет одинаковым, а не работать по правилам этого самого rando-access (пример -> хэшмапа)
# syntax
## init
* для { примитивов, структур и массивов } достаточно использовать `var`, `:=`, `new`
* для ссылочных типов { срезы, мапы, каналы } **необходимо** использовать `make` (он прям вот конструктор)
	* без make инициализируется nil-объект
	* с make инициализируется пустой объект (но не nil)
	* если структура подразумевает использование таких типов, то для неё делается функция-фабрика
* `new` возвращает указатель на nil объект, это надо почти никогда
## memory
> Компилятор сам решает, где ему расположить объект, на стэке или на куче.
### escape analysis
* Внутри функции создаётся объект
* Из функции возвращают объект
* Компилятор видит, что объект собирается выйти за область видимости (его возвращают из функции)
* Компилятор автоматически кладёт такой объект сразу в кучу
## functional
### functions
* функция может вернуть функцию (замыкание)
* функция может вернуть несколько значений `func Foo() (int, string) {}`
* функция может в сигнатуре указать имена возвращаемых значений `func Foo() (timePassedMs int, info string) {}`, только тут тогд внутри пишется всегда пустой `return`
### conditions
> Скобки не нужны
* switch-case
	* можно множество значений в одном case
	* есть default
	* можно указывать переменную внутри + условие
	* можно пустое условие (вместо длинных if else)
* if
	* можно (и даже нужно) указывать переменную перед условием (внутри if)
* тернарников нет...
### loops
* range-based - `for index, value := range anySlice {}`
* classic - `for i := 0; i < 5; i++ {}`, всё, кроме условия, можно убирать
* while - `for true {}`
* loop - `for {}`
### closure
> Замыкание. Лямбда. 
> Анонимная функция, захватывающая все значения из текущей области видимости **по ссылке**
* Интересный пример с сохранением состояния функции (внешней)
```go
func accum() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	a := accum()                         // sum внутри мы "сохраняем в этом скоупе"
	fmt.Printf("we got a = %d\n", a(5))  // 5
	fmt.Printf("we got a = %d\n", a(10)) // 15
}
```
### defer
> Выполнить код в конце текущей области видимости перед возвратом
* Сохраняет состояние области видимости (и объектов) на момент объявления
* Если хотим использовать конечное состояние текущей области видимости -> использовать замыкание
```go
v := exampleStruct{42} // у структуры просто 1 поле int
defer func() { v.PrintInnerValue() }()
v.value = 777
// тут выведется 777, если убрать замыкание в defer, то выведется 42
```
* если их несколько, то выполняются в итоге они в порядке обратном порядку объявления
## types
### strings
> Они все констатные... А-ля всегда стремимся к constexpr...
> Если строку модифицировать - создастся новая обновлённая строка
```go
var basicString := "hello" 
var wideString  := []rune("hello")
```
* char'ов явно нет, поэтому надо оборачивать всё в string для печати, иначе без string() выведет просто код символа
```go
fmt.Printf("print 4th letter of rune -> %s", string(wideString[3]))
```
### slices
> Ровно та же логика, что и у вектора
```go
thisIsArray := [3]int{1, 2, 3}
thisIsSlice := []int{1, 2, 3}

thisIsAlsoSlice1 := make([]int, 0, 2) // len = 0, capacity = 2 => { , }
thisIsAlsoSlice2 := make([]int, 2, 2) // len = 2, capacity = 2 => { 0, 0 }

subSlice1 := thisIsSlice[1:]    // от 2-ого элемента до конца
subSlice2 := thisIsSlice[:1]    // от начала до 2-ого элемента
subSlice3 := thisIsSlice[1:2:1] // от 2-го до 3-го элемента и фиксируем вместимость/capacity на 1  
``` 
* Обычно вместимость возрастает в 2 раза, если append'ится новый элемент свыше текущей вместиомости, но иногда go может принять решение в угоду выравнивания не делать прям х2
* Срезы являются таковыми, потому что по сути они являются view над обычными массивами
* Если копия слайса не меняет свою вместимость, то копия и оринигнал указывают на один и тот же массив в памяти. 
	* Если какой-то из этих двух слайсов меняют свою вместимость, то они начинают указывать на 2 разных в памяти массива. 
	* Вместе с этим некоторые ссылки на их элементы могут быть инвалидированы из-за реалокации
### map
> Она по умолчанию именно хэшмапа
```go
	exampleMap := map[string]int{
		"one":   1,
		"two":   2,
		"three": 3,
	}
```
* Если нам зачем-то нужны только индексы в мапе, то для экономии памяти можно сделать мапу пустых структур `map[string]struct{} { ... }`
* [map-internals-video](https://www.youtube.com/watch?v=P_SXTUiA-9Y&t=1303s)
## panic-recovery
> Паника предзнаначена для случаев, когда восстановить рабочее состояние системы в каком-то случае невозможно
> Однако восстановление языком всё же предусмотрено 
> Если при возврате управления из функции на ближайших стеках не будет вызват `recover()`, а где-нибудь в main() будет, то программа именно запаникует, т.е. ловля panic - такое себе code design решение 
```go
func foo() {
	panic("<Insane panic message>")
}

func recoverFoo() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("inside recovery, we got %v\n", r)
		}
	}()
	foo()
}
```
## OOP substitution
> Вместо ООП интерфейсы и структуры, а потом уже только к ним крепятся разные методы.
> **Важное правило**: если структура реализует все методы интерфейса, то она автоматически удовлетворяет интерфейсу
* Есть интерфейсы, а есть структуры.
	* Интерфейсы декларируют, какие методы есть (и они должны быть реализованы стркутурой, чтобы структура проходила как интерфейс)
	* Структуры содержат поля (аналог -> состояние класса)
* Интерфейс под капотом - некоторая структура `iface` с полями:
	* tab -> это указатель на структуру с информацией о типе интерфейса и типе данных, на которые он указывает
	* data -> указатель на данные
	* ... т.е. интерфейс - структура с типом и значенем
	* [go-interface-internals](https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md#anatomy-of-an-interface)
	```go
	func Build() InterfaceT {
		var res* ExampleStructure;
		return res
	}
	
	func main() {
		// здесь вернётся не nil, а interface с значением в data = nil
		i1 := Build() 
		
		// а вот здесь будет создан nil (т.к. мы не кладём внутрь ExampleStructure)
		var i2 InterfaceT
	}
	```
* Есть ещё пустые интерфейсы, по сути они - Any-типы. Им соответствует любой тип
* Методы указываются вне структуры, как функции, только добавляется *ресивер* после `func` - это имя и тип объекта
	* immutable -> `func (const_obj AnyType) WorkIml() {}`
	* mutable -> `func (mut_obj* AnyType) WorkIml() {}`
* Для соответствия интерфейсу важно, указывается ли мутабельный или имутабельный ресивер
* Такие методы можно "прикреплять" к любым типам, указаным в текущем пакете
	* например для типа `MyFloat`, если указан ранее `type MyFloat float64`
		* соответственно, не получится в качестве ресивера использовать `float64`

## concurrency
> Построено по модели CSP, где есть подзадачи, эти потоки подзадач общаются друг с другом через каналы
* Есть атомики, мьютексы, семафоры, waitGroup (ждёт горутины) и все вроде лежат в *sync* пакете
### goroutines
> Стейтфул корутины, запускаются через `go`
* `main` тоже горутина =)
* горутины часто имеют "уступающий харакетр", т.е. вполне непрочь уступить аптайм следующей горутине
* планировщик горутин -> [поверхностно](https://www.youtube.com/watch?v=rloqQY9CT8I)
* очердь горутин простая (не приоритетная)
### channels
> Каналы общения между горутинами
> Буфферизированные каналы просто имеют какого-то размера буффер...
* попытка записи в полный канал -> блокировка, пока не появится место в нём
* попытка чтения из пустого канала -> блокировка, пока не появится значение
```go
    ch := make(chan int)               // только для int
    bufferedCh := make(chan string, 5) // размером в 5 строк
	
	ch <- value           // отправить значение в канал
    receivedValue := <-ch // получить значение в переменную
```
> Аксиомы:
* nil channel
	* отправка в него -> блокировка навсегда
	* выгрузка с него -> блокировка навсегда
	* закрытие -> panic
* закрытый канал
	* отправка в него -> panic
	* выгрузка с него 
		* канал пуст -> { дефолтное значение, false }
		* канал не пуст -> { актуальное значение, true }
	* закрытие -> panic
* буфферизированный канал
	* отправка в него
		* полон -> блокировка
		* не полон -> ок
	* выгрузка с него
		* пуст -> блокировка
		* не пуст -> ок
* закрытие канала - атомарная операция (вроде)
* поведение каналов не зависит от времени исполнения кода, только от состояния
### select
> Специальная инструкция для мультиплексирования каналов.
> switch-case-like конструкция, которая вызывает тот case, где первее происходит исполнение.
> `default` - вызывается на случай, если все остальные case'ы заблокировали основной поток 
```go
	ch1 := make(chan string)
	ch2 := make(chan int)

	go func() {
		time.Sleep(100 * time.Millisecond)
		ch1 <- "huh"
	}()

	go func() {
		time.Sleep(50 * time.Millisecond)
		ch2 <- 42
	}()

	// горутина с int будет быстрее всех, его case и выполнится
	select {
	case number := <-ch1:
		fmt.Println("Got from 1 -> ", number)
	case str := <-ch2:
		fmt.Println("Got from 2 -> ", str)
	case <-time.After(200 * time.Millisecond):
		// Трюк с таймаутом, если вдруг прошлые case не выполнились за 200мс
		fmt.Println("Procced timeout")
	}

	// если канал оказался заполненным, то будет default
	tinyCh := make(chan int, 1)
	select {
	case tinyCh <- 1:
		fmt.Println("Sent successfully")
	default:
		fmt.Println("Channel is busy")
	}

```

# GMP, планировщик
- [fine video](https://www.youtube.com/watch?v=8z6FAaNPA-M&t=237s)
> GMP — это модель планировщика горутин в Go, состоящая из трёх компонентов:
-  G (goroutine) — сама горутина, единица выполняемого кода.
-  M (machine) — системный поток ОС, на котором выполняется G.
-  P (processor) — логический процессор, владеющий очередью задач и управляющий выполнением G.

- Каждому P соответствует одна очередь горутин, и количество P определяет количество одновременно выполняемых горутин (ограничивается через *GOMAXPROCS*).
- Когда M свободен и есть активный P, он берёт G из очереди и выполняет. Это позволяет планировщику балансировать и масштабировать задачи без участия ОС.
