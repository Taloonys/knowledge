---
tags: [databases]
aliases: [Partial index]
---

> **Индекс** - механизм ускорения запросов в БД. 
> Можно представить его механизм работы как хэш-мапу. Нужно конкретно значение атрибута? - Прыгай сразу на конкретную позицию.
> Только работает он не строго как хэшмапа... Есть разные его виды...

* Пример создания индекса на жанр книги (может часто будем искать в электронной библиотеке)
```sql
CREATE INDEX [index_name]
ON [table_name] ([column_name], ...);

CREATE INDEX [book_genre_index]
ON books (genre);
```
* Вставка индексов часто требует сканирования всех нужных таблиц
* Не стоит добавлять индексы в таблицы, где очень часто происходит изменение данных, т.к. индексы должны быть всегда актуальны (постоянно поддерживаться)
* Стоит их использовать там, где эти данные чаще читают (`WHERE`, `ORDER BY`, `GROUP BY`)
* **Не стоит использовать на маленькие таблицы**
* Полезные в `JOIN` операциях
* Не стоить их использовать для столбцов, где много `NULL` данных
* Если создали композитный индекс, то ускорение запроса по обращению к одному из этой пачки индексов будет только для первого по порядку поля
```sql
CREATE INDEX [phone_charstx_idx]
ON [phones] (type, os, cpu)

-- ...
WHERE os = "Android" -- index won't work!

-- ...
WHERE type = "Sensor" -- index is working
```
* У индексов **есть ограничение на размерность** в разных СУБД
```sql
CREATE INDEX [book_genre_index]
ON books (genre, photo, rating);
-- если колонны genre + photo превышают, например, 1700 байт (MySQL) в общей сложности
-- .. то на rating не будет создан индекс
```
* В PostrgeSQL есть правило о создании композитных индексов. Если есть какой-то частый запрос, то по нему можно составить **композитный индекс до первого неравенства включительно**, т.е.:
```sql
-- Допустим, что частый запрос такой:
SELECT * FROM employees 
WHERE last_name = "Иванова"
	AND sex = "female"
	AND SALARY > 150000
ORDER BY hired_at;

-- Тогда такой индекс будет бесполезен, а если точнее, timestamp в таком индексе ничего не даст
CREATE INDEX [useful_female_idx]
ON employees (last_name, sex, salary, hired_at);
```
* **Не стоит создавать индекс на низкоселективные колонки** (это где в колонке мало разных значений, например несколько тысяч значений разных для бд на 50кк записей это ещё относительно недостаточно), оптимизатор может иногда такое проигнорировать, а иногда нет.. тогда скорость выполнения запроса может даже ухудшится
* Стоит понимать, что если в поле может быть значения 1..99999999, а частый запрос к бд - "выбрать ... с значением выше 200", то для такого делать индекс бессмысленно
# Partial index
> Индексация также работает с логикой по типу `WHERE`

* Например, можно проиндексировать книжки с ценой от 1300
```sql 
-- ну и надеемся, что цены книг вариаруются от 500 до 1600
CREATE INDEX bux_price_idx
ON books (price) where price > 1300
```

# Index clusterisation
> В некоторых СУБД есть такая концепция кластеризации индексов...
## Clustered index
* Некоторый индекс по умолчанию, по которому определяется порядок данных в таблице. 
* В 1 таблице может быть только 1 кластеризованнный индекс.
* Данные в таблице хранятся в виде В-дерева, где нодами являются строки данных
* Полезно в случаях, когда на ключ часто будут применять `WHERE`, `ORDER BY`, `JOIN`
## Non-clustered index
* Отдельная структура, которая хранит индексы и соответствующие данные в отдельной таблице
* Требует явного задания
* В 1 таблице может быть несколько некластеризованных индексов
* Данные в таблице хранятся в виде В дерева, где нодами являются уже указатели на строки в оригинальной таблице
* Полезно в случаях, когда на не первичном ключе будут часто использовать `WHERE`
# Types
> Тип индексов насильно выбрать нельзя, можно лишь где-то как-то подсказывать (и то маловероятно, что оптимизатор запросов послушает) или выставить в настройках предпочтения.
## B-tree
* Наиболее распространённый тип индекса, по сути представляет собой сбалансированное дерево поиск O(log n)
* Поддерживает быстрый поиск, вставку, удаление и обновление данных
* Эффективен для операций сравнения (`=`, `>`, `<`, `BETWEEN`)
* Подходит для большинства сценариев
## Hash index
* Использует хэш-таблицу для поиска данных, ну и поиск О(1)
* Эффективен только для точного поиска (`=`)
* Не поддерживает диапазонные запросы или сортировку
* Применяется редко, обычно в специализированных СУБД
## Bitmap index
* Представляет каждого уникальное значение как битовую маску
* Используется для столбцов с небольшим количеством уникальных значений (например, пола или статуса)
* Эффективен для операций `AND`, `OR`, `NOT`
* Не подходит для часто изменяемых данных
## Full-text index
* Индексирует все слова в тексте, позволяя осуществлять поиск по ключевым словам в текстовых данных
* Поддерживает сложные запросы, такие как поиск по ключевым словам или фразам
* Применяется в СУБД, которые работают с большими текстовыми данными (например, PostgreSQL, MySQL)
## Spatial index
* Представляет собой структуры по типу R-дерева
* Используется для геоданных (например, координат)
* Поддерживает операции, такие как поиск ближайших объектов или пересечение областей
* Применяется в СУБД, работающих с геоданными (например, PostGIS для PostgreSQL)
## Composite index
* Индекс, созданный на несколько столбцов, Данные сортируются сначала по первому столбцу, потом по второму
* Эффективен для запросов, которые используют несколько условий в `WHERE`
* Порядок столбцов в индексе важен: запросы должны использовать префикс индекса