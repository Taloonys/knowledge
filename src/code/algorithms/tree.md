---
tags: [code, algorithms]
aliases: [Бинарное (двоичное) дерево]
---

> Деревом называют структуру данных, которая представляет собой совокупность элементов, а также отношений между этими элементами, что вместе образует иерархическую древовидную структуру. 

Как уже было указано выше, есть 3 типа сложности операций: вставка, удаление, поиск. Связный список справляется со поиском O(N), что довольно долго. Так же сортировка будет занимать O(N), т.к. каждый раз надо будет переставлять множество элементов. Для этой задачи хорошо подходят деревья.

![Untitled](../../../images/code__algorithms__Untitled%205%201.png)

* **Корень** - самый “верхний” элемент дерева
* **Ветки** - связи между элементами
* **Узлы или Node'ы** - все "промежуточные" элементы дерева 
* **Листья** - самые “нижние” элементы
* Можно называть все элементы **нодами** и не страдать =)

## Бинарное (двоичное) дерево
> Дерево, где у каждой ноды есть не более 2 дочерних нод.

![Untitled](../../../images/code__algorithms__Untitled%206%201.png)

![Untitled](../../../images/code__algorithms__Untitled%207%201.png)

## Бинарное (двоичное) дерево поиска
> Бинарное дерево, где на одной стороне дочерние ноды большие по значению, а на другой - меньшие. Т.е. предусмотрена заранее некоторая сортировка

![Untitled](../../../images/code__algorithms__Untitled%208%201.png)

Для проверки операций вставки или удаления существуют методы обхода дерева:
- **Симметричный обход** - выводится самый левый ребёнок, родитель, самый правый ребёнок, родитель.
- **Обратных обход дерева** - сначала выводится левый ребёнок, затем правый ребёнок, а затем так же с родителями.

![Untitled](../../../images/code__algorithms__Untitled%209%201.png)

![Untitled](../../../images/code__algorithms__Untitled%2010%201.png)
## Двоичная куча
* все уровни, кроме последнего, полностью заполнены, последний заполняется слева направо
* есть 2 типа:
	* min-heap -> каждый родитель `<=` потомков
	* max-heap -> каждый родитель `=>` потомков
* довольно часто хранится именно в массиве, а не вот отдельными структурами как выше
* insert/extract -> O(log n)
* get min / max -> O(1)
## Префиксное дерево
> Это дерево, где каждая нода - один символ. Используется на code auto-completion, подсказок поиска в браузере и т.п.
```css
(root)
 ├── c
 │   └── a
 │       ├── r*
 │       └── t*
 └── d
     └── o
         └── g*
```
* `(*)` — конец слова (флаг окончания)
* root - обычно пустой `""`
* поиск и вставка -> **O(n)**, где n - именно длина слова
## Балансировка
> Дерево будет являться **сбалансированным**, если **разница высот между дочерними узлами по модулю меньше или равна единице**. 
## AVL дерево
> В бинарном дереве поиска можно заметить, что процесс поиска самого максимального или самого минимального значения (самый правый нижний и левый элементы соответственно) будет иметь алгоритмическую сложность O(n). Для решения такой проблемы придумали AVL деревья, отличием которых от бинарного дерева поиска является **балансировка дерева** во время добавления или удаления узла. Такое дерево обладает **логорифмической сложностью на всех операциях**.

![Untitled](../../../images/code__algorithms__Untitled%2011.png)
В то время как **высотой узла** будет являться самый длинный путь от его ребёнка до листа, включая самого ребёнка и лист.
![Untitled](../../../images/code__algorithms__Untitled%2012.png)
Если разница составляет отрицательное число (вычитаем высоту левого узла из правого), то такое дерево будет  называться перегруженным влево, если положительным - перегруженным вправо.
![Untitled](../../../images/code__algorithms__Untitled%2013.png)
Механизмом балансировки деревьев являются **повороты вправо** и **влево** относительно некоторого узла.
![Untitled](../../../images/code__algorithms__Untitled%2014.png)
Также существуют правый-левый повороты и левый-правый, для того, чтобы понять нужны ли они нам - необходимо проводить проверку балансировки и дочерних узлов.
![Untitled](../../../images/code__algorithms__Untitled%2015.png)
## Красно-чёрное дерево
> AVL дерево подразумевает огромное кол-во операций расчёта балансировки дерева помимо самих операций поиска, вставки и удаления. Для этого придумали красно-чёрное дерево, которое всегда остаётся сбалансированным. **Каждый узел дерева** теперь имеет **красный** или **чёрный** цвет.

* ***Каждый лист дерева** - **null-чёрный узел**. 
* **Корень** дерева **всегда чёрный узел**. 
* У **красного узла оба ребёнка** должны быть **чёрными**. 
* Так же вводится наличие такого параметра как **чёрная высота** - кол-во чёрных узлов на **любом пути** от узла до null-листа (null-лист включительно), “любой” здесь означает, что такая высота должна быть везде одинаковой.
![Untitled](../../../images/code__algorithms__Untitled%2016.png)
Вставка красных элементов более “безопасная”, т.к. не ломает логику с чёрной высотой. Ниже представлены возможные случаи вставки
![Untitled](../../../images/code__algorithms__Untitled%2017.png)
# Сравнение сложности операций массивов, списков и деревьев.
[https://habr.com/ru/articles/188010/](https://habr.com/ru/articles/188010/)
![Untitled](../../../images/code__algorithms__Untitled%2018.png)

# B-tree
> Эта структура данных ориентирована на операции чтения с диска, то есть: 
> - на последовательное чтение (в одной ноде несколько страниц памяти)
> - на блочную стркутуру (сами страницы памяти),
> - на проблематику произвольного доступа, операция поиска к пачке страниц O(log N)
> - на проблему кол-ва обращений к памяти (т.к. данные считываются по множество страниц за одно обращение)

 * B-дерево является идеально сбалансированным, то есть глубина всех его листьев одинакова. 
 * B-дерево имеет следующие свойства (t — параметр дерева, называемый _минимальной степенью_ B-дерева, не меньший 2
- Каждый узел, кроме корня, содержит не менее t−1 ключей, и каждый внутренний узел имеет по меньшей мере t- дочерних узлов. 
- Если дерево не является пустым, корень должен содержать как минимум один ключ
- Каждый узел, кроме корня, содержит не более 2t−1 ключей и не более чем 2t- сыновей во внутренних узлах
- Корень содержит от 1 до 2t−1 ключей, если дерево не пусто и от 2 до 2t детей при высоте большей 0
- Каждый узел дерева, кроме листьев, содержащий ключи k1,...,kn , имеет n+1 сына. i-й сын содержит ключи из отрезка [ki−1;ki],k0=−∞,kn+1=∞-
- Ключи в каждом узле упорядочены по неубыванию
- Все листья находятся на одном уровне
![](../../../images/code__algorithms__B-tree-definition.png)
# R-tree
> Структура данных рассчитанная на представление пространственной метрики.

* Пример из 2д пространства
* Алгоритм вставки основывается на том, в какой "регион" (для ассоциации с картами) в наибольшей мере соответствует "вставляемый регион", таким образом разрешается вопрос близости объекта в пространстве.
* Поиск в таком случае O(log N)
![](../../../images/code__algorithms__R-tree.svg.png)
* Существуют и модификации такого дерева, например R+-tree (больше ориентирован на хранение x,y координат + одни и те же координаты могут помещаться в несколько узлов по необходимости), X-tree (относится к измерениям порядка повыше) и т.п.