---
tags: [code, algorithms]
aliases: [Find longest polyndrome in string]
---

# Find longest polyndrome in string
> Специализированный алгоритм, который позволяет решить проблему за О(n)
> [link](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm)
> Суть в попытке использовать: результаты по уже найденным полиндромам, отзеркаливании, радиусах и предположении, что длиннее палиндрома уже быть не может.
* сначала строка **заполняется некоторыми разделителями**, чтобы не различать (не-)чётность длины строки
* заводится **вспомогательный массив** `P` (просто пока нулевой с длиной 2n + 1) с максимальными радиусами палиндромов
* заводятся переменные центра (пусть будет `С`) и правой границы  (пусть будет `R`) *самого правого палиндрома*, пока не думаем, что это такое, просто палиндром
* проходим по всем элементам строки с разделителями
	* расшерением от каждого символа вычисляем максимальные паландромы относительно каждого центра
	* вычисляется зеркальный центр (такой же центр симметричный относительно текущего центра `С`) `mirror = 2*C - i`
	* если мы на итерации `i < R`, т.е. внутри уже известного палиндрома, то начальный радиус для такой итерации можем брать сразу как `min(P[mirror], R - i)`
	* пытаемся расширить текущий палиндром за пределы `R` 
		* если получается -> обновляем центр `С` и `R = i + P[i]`, теперь у нас новый **самый правый** палиндром
* теперь среди `P` находим самый максимальный радиус и его `i`, где `i` - центр палиндрома (как изначально задумывали)
* возвращаем `string[i-P[i] : i+P[i]+1)` + учитываем, что мы вставили лишние разделитили, это и будет самый длинный палиндром
  