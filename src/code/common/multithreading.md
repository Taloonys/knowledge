# Base terms

> Многопоточность была ещё в ПЭВМ (ПК), где был всего 1 процессор (и 1 поток). 
> Как она реализовывалась? - был некоторый механизм, который в какие-то моменты времени переключался на другую задачу, быстренько просматривался статус или ещё что-то и происходило переключение обратно.

- Подобного рода имитация параллельности можно именовать как **псевдопараллельное выполнение**.
- **Многозадачность** - способность среды выполнять параллельно или псевдопараллельно (например асинхронщина) несколько задач
- **Многопоточность** - способность окружения выполнять в одном контексте несколько задач параллельно за счёт использования нескольких потоков
- **Процесс** - некоторая программа, которая может содержать в себе:
    - потоки
    - открытые дескрипторы (сокеты, файлы и т.п.)
    - дочерние процессы
    - адресное пространство
    - и т.п.
	
## **Поток**
> В контекста программирования: поток - *независимая последовательность выполнения инструкций внутри одного процесса с общей памятью, но собственными регистрами и стеком*.

- без специальных механизмов синхронизации у нас нет никакой возможности узнать, какой поток какое состояние имеет в данный момент времени или же, что он выполняет

# Sync primitives
## mutex
## atomic
## condition variable
## semaphore
> разрешает лишь нескольким потокам смотреть на критическую секцию
### counting
 > как и задумано... хранит внутри себя **счётчик**!

* инитится семафор с кол-вом потоков, которым будет доступен ресурс
* `wait()` или `acquire()`:
	* если счётчик уже 0, то текущий поток блокируется, пока он не станет равным 0
	* если счётчик не 0, то текущий поток попадает в крит. секцию и тогда счётчик уменьшается на 1
* `release()` или `post()` - выходи из критической секциии и увеличивают счётчик на 1

```cpp
counting_semaphore<2> semaphore(2); 

void worker_function(int id) {
    semaphore.acquire();
	
    this_thread::sleep_for(chrono::seconds(1)); 
	
    semaphore.release();
}

int main() {
    thread t1(worker_function, 1);
    thread t2(worker_function, 2);
    thread t3(worker_function, 3);
    thread t4(worker_function, 4);

    t1.join();
    t2.join();
    t3.join();
    t4.join();

    return 0;
}
```
### binary
> смысл тот же, только у нас всего 1 поток...
> суть семафора в таком случае - просигнализировать из другого потока, что мы можем зайти в критическую секцию

- фактически это замена:
	- mutex + condition variable (он просто не всегда во всях яп или ос ок с сигналами)
	- spinlock + atomic
	
```cpp
// 0 (non-signaled state initially)
binary_semaphore prepareSignal(0);

vector<int> myVec{};

void prepareWork() {
    myVec.insert(myVec.end(), {0, 1, 0, 3});
    cout << "Sender: Data prepared.\n";
	
    prepareSignal.release(); // POST
}

void completeWork() {
    cout << "Waiter: Waiting for data.\n";
	
    prepareSignal.acquire(); // WAIT
    
    myVec[2] = 2; // Modify the shared data
    cout << "Waiter: Complete the work. Data: ";
}

int main() {
    thread t1(prepareWork);
    thread t2(completeWork);

    t1.join();
    t2.join();

    return 0;
}
```
## signals
## events