> **Кэширование** - методология запоминания данных в "точке доступа" поближе.
> Проще запомнить какой-то ответ и при повторном запросе его же и отдать, нежели каждый раз проходить долгий путь до БД и отдавать те же самые данные.
* Самый яркий пример -> **Redis (TODO)**
* Кэшировать можно что угодно (в плане субъектов, а не всё подряд)
* **Есть несколько видов:**
	* **pull-based** - если кэша у CDN нет, он пуллит кэш с оригинального сервера и отдаёт юзеру, используется для частого отображения неизменяемых данных
	* **push-based** - CDN пушит свои данные на основной сервер, а тот уже раздаёт всем CDN эти данные
![Pasted image 20241026234554](../../images/system-design__Pasted%20image%2020241026234554.png)
# Target criteria
* Высокая нагрузка на чтение
* Часто запрашивается мало изменяемая информация
# Cache Ratio
> Если запрашиваемые данные обнаружены в хранилище кэша - это называется **cache hit**, если нет - **cache miss**.
> **cache ratio** - отношение **cache hits** к **cache hits + cache misses**

![Untitled](../../images/system-design__Untitled%202.png)
# Подходы/стратегии кэширования:
## Полное кэширование
> При этом подходе все данные или результаты хранятся в кэше, что обеспечивает мгновенный доступ к полному набору информации. Этот метод подходит, когда объем данных невелик и их можно эффективно разместить в памяти.
## Частичное кэширование
> Здесь в кэш помещается лишь часть данных, обычно часто запрашиваемые или самые используемые. Это решение предпочтительно для больших наборов данных или в ситуациях, когда не все данные постоянно востребованы.
## Кэширование с установленным временем жизни
> Данные кэшируются на заданный период, после чего информация считается устаревшей и обновляется из первичного источника. Этот метод подходит для данных, которые не часто изменяются.
## Eviction policies
> Политика по удалению данных из кэша для исключения ситуации его переполнения
### LRU, LFU, FIFO
> LRU - Least Recently Used
> LFU - Least Frequently Used
> FIFO - First in first out
> 
> В рамках этих подходов из кэша удаляются неиспользуемые данные для освобождения пространства для новой информации. Они целесообразны, когда пространство кэша ограничено.
## Write-around, Write-through, Write-behind (write-back)
> При write-through стратегии данные записываются одновременно в кэш и в первичный источник, в то время как write-behind стратегия предполагает запись сначала в кэш, а затем и в источник. Эти методы используются для поддержания согласованности между кэшем и источником данных.
### Write around
> Спрашиваются данные, если они есть в кэше 
> 	-> если есть в кэше, то возвращаются из кэша
> 	-> если нет в кэше, то проверяется есть ли в БД
> Далее данные с БД отдаются серверу, а сервер их ещё кэширует
* Используется, **когда очень важна быстрая запись**
### Write-through
> Данные одновременно записываются и в БД, и в кэш. 
* Данные одинаковы для кэша и БД, но страдает скорость записи
### Write-back
> Данные сначала пишутся в кэш, а затем в БД.
* Полезно, когда нужно повысить скорость записи, однако возникает риск, что некоторые данные будут утеряны, если сервер упадёт
## Распределенное кэширование
> При таком подходе кэш разбрасывается по нескольким узлам или серверам с использованием облачных решений
* Высокая доступность и скорость (сервисы обычно гарантируют некоторую отказоустойчивость)
* Легко масштабировать (сервисы умеют в auto-scaling)
* Низкие затраты (дешевле физических серверов)
* Сильно зависит от интернет соединения
* Сложно вот так отдалённо этим управлять
* Облако не всегда удовлетворяет требованиям к безопасности продукта
* Сложно интегрировать
* Как-то надо персонал этой технологии обучать...
## Пользовательское кэширование
> Разработчики могут создавать индивидуальные стратегии кэширования, которые наилучшим образом соответствуют уникальным требованиям и особенностям системы. Это может включать в себя сочетание упомянутых выше стратегий или разработку собственных инновационных подходов.
# Hardware
> Цены на 2024г в руб, указаны не более чем для соотношения
### HDD
- **Стоимость**: ~2–5 руб./ГБ (дешёвые)
- **Объём**: 500 ГБ – 22 ТБ (бытовые – серверные)
- **Скорость**: 80–200 МБ/с (SATA HDD)
### SSD
- **Стоимость**: ~5–15 руб./ГБ
- **Объём**: 250 ГБ – 8 ТБ (NVMe) / до 16 ТБ (SATA)
- **Скорость**:
    - SATA: 500–600 МБ/с
    - NVMe (Gen4/Gen5): 3–14 ГБ/с
### RAM (DDR4/DDR5)
> Считается золотой серединой
- **Стоимость**: ~10–30 руб./ГБ
- **Объём**: 8–256 ГБ (обычные ПК) / до 2 ТБ (серверные платформы)
- **Скорость**: 20–100 ГБ/с (пропускная способность)
### **CPU Cache + Registers**
> Но, конечно, этим пользуются только операционки...
- **Стоимость**: ~1000+ руб./МБ (косвенно, через процессоры)
- **Объём**:
    - L1: 32–64 КБ на ядро
    - L2: 256 КБ – 2 МБ на ядро
    - L3: 8–128 МБ (общий для чипа)
- **Скорость**: ~500–2000 ГБ/с (latency в наносекундах)

## Связанные записи
- [Query optimisation и индексы](../databases/query-optimisation.md)
- [Индексы](../databases/index.md)
- [Replication](replication.md)
- [CDN](cdn.md)
  
