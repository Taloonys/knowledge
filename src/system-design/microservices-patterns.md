---
tags: [system-design]
aliases: [Application patterns]
---

> Прям полезный сборник всех паттернов: https://microservices.io/patterns/
# Application patterns
## Saga
> Подход, при котором транзакция делится на множество мелких этапов или **локальных транзакций**, а также подразумевает, что в случае ошибки производятся **компенсирующие действия**.
* Хранит для этого файлы состояний конфигураций
### Orchestration
> Есть некоторый оркестратор, который по порядку (или параллельно, если возможно) отправляет локальные транзакции сервисам, а потом на основе совокупности всех запросов принимает конечно решение (проводим транзакцию или нет)
* Когда важен порядок операций
* Когда комплексные операции
* Когда централизованное управление сильно помогает в поддержке сервиса
* Когда важна транзакционная согласованность
### Choreography
> Подход, при котором сервисы могут осуществить свою транзакцию и совершить, например, последующий запрос другому сервису, такие сервисы также могут применять компенсирующие действия самостоятельно.
* Когда микросервисы по природе независимы
* Примитивные операции
* Важна масштабируемость
* Довольно удобно использовать в EDA
## CQRS
> **Command Query Responsibility Segregation** - паттерн проектирования, который разделяет чтение (Command) и запись (Query) на 2 отдельный интерфейса.
* Оба логических сегмента (чтение и запись) удобно масштабировать по-отдельности
* Запросы теперь не конкурируют друг с другом
* Согласованность данных
* Немного неудобная реализация
* Разделение "на каналы" ведёт к повышению сложности кода
## Database per Service
> Из названия -> у каждого сервиса должна быть своя отдельная база данных (если нужна)
* Изоляция данных, сервисы не будут конкурировать за них
* Разные сервисы могут использовать разные типы БД
* Микросервисы со своими БД изолировано от других сервисов масштабируются и обновляются 
* Больше сущностей => сложнее управление
* Особенно остро стоит вопрос о согласованности данных
## Service per Team
> Каждая команда разработки отвечает только за свой микросервис (или несколько других)
### Теорема Конвея
> *Любая организация, которая проектирует систему, неизбежно создаёт дизайн, который копирует структуру коммуникаций этой организации.*
* гибкая и понятная коммуникация
* чёткие границы ответственности
* возможна конфликтность команд
* различие технологий может усложнить интеграцию фич
## Event Sourcing
> Система сохраняет каждое событие в некотором "журнале", таким образом состояние системы можно воспроизвести по этому журналу как раз с помощью наборов событий.
* Легко воспроизвести состояние системы
* Удобно добавлять мониторинговые системы
* Согласованность данных
* Это нужно реализовать, и это немного тяжко...
* Нужно решать вопрос с тем, как много событий можно хранить
# Application infrastructures patterns
## API Gateway
> Образование единой точки входа во всё приложение
* [API](api-management.md)
## Distributed Tracing
> Все запросы в распределённой системе трассируются (запоминаются все цепочки кто и от кого)
* Наблюдаемость системы
* Проще диагностировать
* Мониторинг перфоманса системы и помощь в обнаружении долгих мест
* Сложно реализовать
* Трассировка всего подряд - довольно серьёзная нагрузка на запросы
## Audit Logging
> Все запросы "от кого и куда" записываются в единый журнал
* Удобно расследовать инцеденты
* Можно отследить все изменения
* Безопасность
* Большие журналы занимают много места...
* Нужно организовать как-то хранение журналов и работу с ними
## Circuit breaker / предохранитель
> Если операции слишком частые и понятно, что они не будут успешными, то такие операции блокируются на время
* Разгружает системы от спамма сбоев
* Неправильная установка порогов может привести к тотальным отказам в обслуживании
# Infrastructures patterns
## Service Discovery
> Автоматическое обнаружение подключаемых сервисов.
> На практике это реализуется devops утилитами, например, такое есть в kubernetes
* Автоматизация подключения
* Устойчивость к сбоям с помощью автоматического переключения на другие сервисы
* Удобство масштабирования
* Сложность реализации
* Обнаружение может замедлить запросы
## Service Mesh
> Все сервисы обычно общаются через общий сервис, по смыслу это почти API, но это не входная точка приложения, а именно сетевой интерфейс.

![](../../images/system-design__9ljcaaldk2rufoxahoq08ltyhr0.png)
* Безопасность (все запросы под шифрованием)
* Полный и централизованный мониторинг запросов и управление политиками
* Сложная реализация
* Могут быть задержки запросов
## Service Registry
> Есть общий реестр, в который сервисы сами ходят регестрироваться.
>  А такой регистр просто предоставляет информацию о зарегестрированных сервисах какому-нибудь API
* Упрощённое и централизованное управление
* Удобно и легко интегрировать в другие системы
* Единая точка отказа
---
# Error treat strategies
> Это не категория паттернов, но оставлю я это пока тут...
* Методы ниже применяются чуть ли не всем скопом сразу обычно...
## Компенсационные транзакции
* Удобно следить за data consistency
* Удобно сохранять промежуточные результаты
* Писать кучу описаний { Do + Undo } человеку тяжко...
* А ещё с этим удвоенным набором транзакций тяжко обеспечивать изоляцию данных и их консистентность
## Retry
* Для временных ошибок
* Может увеличить нагрузку системы
## Timeout
* Ошибки не приходится долго ждать, улучшает отклик системы
* Не решает проблемы
## Circuit breaker / предохранитель
> Если операции слишком частые и понятно, что они не будут успешными, то такие операции блокируются на время
* Разгружает системы от спамма сбоев
* Неправильная установка порогов может привести к тотальным отказам в обслуживании
## EDA
> Event Driven...
* Лёгкая расширяемость + удобный отклик другими сервисами
* Неудобно отслеживать состояние транзакций
* Настройка EDA всегда тоже требует некоторой надёжности и отдельной настройки
## Мониторинг и алерты
> **Prometheus**, **Grafana**
* На алерты может реагировать специальная команда (людей)
* А как жить с ложными срабатываниями?
* Настройка отдельная
## Tools
* Long Running Actions for MicroProfile - для длинный транзакций
* Axon - CQRS + Event Sourcing + DDD (Domain Driven...)
* Seata Saga Mode - для длинных транзакций
* Eventuate Tram Sagas - JDBC и JPA используют
* Oracle Database
* Apache Camel Saga