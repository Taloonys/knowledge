> **Масштабируемость** определяет возможность системы или приложения эффективно управлять увеличивающимся объемом работы или растущим числом пользователей без заметного снижения производительности или функционала.

* ***Масштабировать можно любой компонент системы, будь-то load-balancer'ы, базы данных, прокси и т.п.**

![Untitled](image-storage/Untitled%203.png)

# Types
## Вертикальная масштабируемость
> Добавление бОльших ресурсов конкретному устройству -> т.е. добавить больше плашек ОЗУ, поставить мощнее процессор и т.п.
### Приемущества:
- **Упрощенное управление** - проще присматривать за одним узлом, чем за огромным кластеров узлов
- **Согласованность** - раз все данные хранятся на одном узле, то нет нужды реализовывать общение данными между узлами
- **Повышение производительность** - небольшая прибавка к мощности узла может существенно повысить производительность системы

## Горизонтальная масштабируемость
> Добавление бОльшего кол-ва инстансов сервисов или БД. 
> Сервис умирает от нагрузки? - Создадим новый и частично трафик на него перенаправим...
### Преимущества:
- **Улучшенная масштабируемость** - не вывозит? - просто добавь воды и больше серверов
- **Повышенная отказоустойчивость** - меньше шансов у узла отказать, а если и откажет, то его работу можно перекинуть другим
- **Экономичность** - вместо одного супермощного узла можно купить много дешёвых
## Облачное масштабирование
> Буквально оба прошлых подхода, но с использованием ресурсов облачных сервисов хранилищ. По факту это гибридная архитектура.
* Легко поддерживать
* Малое кол-во расходов (проще чем купить кучу пк и серверов)
* Часто такие сервисы предлагают собственные гарантии надёжности и авто-масштабирования
* Гарантируется резервное копирование
* Сервис может предлагать гео распределение
* Гарантируется некоторая безопасность... Однако некоторые продукты имеют куда более строги правила к безопасности, тогда облачная архитектура вообще не подойдёт...
* Сложно интегрировать
![](image-storage/Shardy_i_repliki_v_georaspredelennoi_srede_2_1721207553.png)
# Load profiles
## Статическая нагрузка
> Пример: ночью на сервер почти никто не заходит
* Подходит любой тип масштабирования
## Динамическая
### Регулярная и предсказуемая
> Пример: В понедельник сотрудники скопом заходят на корпоративный портал
* Подходит репликация, кэширование и шардирование (по возможности можно включить и геофактор)
### Нерегулярная
#### Предсказуемая
>Пример: При выпуске нового обновления игры статистически появляется наплыв пользователей
#### Непредсказуемая
> Пример: Какой-то товар вдруг начал пользоваться своей популярностью и все резко решили его купить из-за кучи обзоров в YT
* Важно иметь орекстратор с возможностью автоматического масштабирования (например Kubernetes)
# Methods
* [Replication](replication.md)
* [Sharding](sharding.md)
* [Cache](cache.md)
## Geo distribution
> Если данные свойственны для некоторый страны, то проще их разместить в каком-нибудь сервисе-центре этой же страны, чтобы минимизировать задержку запроса через тысячи км.
* [CDN](cdn.md)
## Auto-scaling
> Средство devops сферы, которое может анализировать состояние инстанса и клонировать его, если основной инстанс не справляется с нагрузкой
## Different DBs
> Использование разных типов БД, позволяет облегчить нагрузку на сервер за счёт "логической оптимизации запросов". 

* Например MongoDB для неструктурированных данных
  (Mongo - документоориентированная БД, т.е. можно в json положить любые данные и хранить так)
* Например GraphQL, если вполне нормальная ситуация, что могут быть абсолютно разные и непредсказуемые запросы в БД 
  (GraphQL - БД + протокол, т.е. , грубо говоря, можно из внешнего сервиса делать почти напрямую обращене в БД)
* Например колоночные СУБД для аналитики 
  (Проще искать конкретные метрики и статистику именно по ним.. в виду их природы...)
# System types
* **Statefull** - система сохраняет где-то состояние о взаимодействии с клиентом. 
  Проблемой тут может быть случай, когда есть несколько инстансов и лишь один из них должен хранить состояние, т.е. клиенту нужно всегда попадать на этот инстанс.
* **Stateless** - система никак не сохраняет информацию и прошлых состояниях, каждое взаимодействие как новое. 
  Сохранение в БД не является тем самым состоянием. Т.к. каждый запрос клиента вполне себе независимый от других его запросов. Но информация о нём, действительно, хранится в БД пользователей. 
  Такие системы просто масштабировать.