> **Балансировка нагрузки** представляет собой методику, применяемую в распределенных системах и сетевых структурах для равномерного распределения входящего трафика и рабочей нагрузки между множеством серверов или операционных узлов. 
> Это предотвращает перегруженность отдельных серверов или ресурсов, обеспечивая тем самым более эффективное использование.

![Untitled](image-storage/Untitled%205.png)
# Types
## Physicly
* **Программные** - работают отдельным сервером, через них и проходит трафик системы.
* **Виртуальные** - обычно прям отдельной почти виртуалкой работает, обычно применяется в облаках и "покрупнее" программных.
* **Аппаратные** - это вот прям отдельное устройство, к которой подключают кабели, наивысшая скорость, работает в банках и прочих крупных компаниях.
![Pasted image 20241027124604](image-storage/Pasted%20image%2020241027124604.png)
## OSI based
* **On transport level** - анализирует строго от кого и куда, поэтому работает тако lb (load balanced) быстрее всего
* **On application level** - обычно анализирует содержимое пакета и может принимать более сложные логически решения, куда отправить запрос
# Стратегии
>Ниже представлены стандртные/общие стратегии, но так же есть и 
# Random
> Из названия -> кинуть запрос в случайный сервис
## Круговой метод (Round Robin)
> Этот подход равномерно распределяет поступающие запросы между серверами или ресурсами по принципу очередности, обеспечивая справедливое распределение нагрузки между всеми участниками.

Балансировщик поочереди раскидывает всем нагрузку, как только доходит до последнего сервера, то возобновляет распределении нагрузки начинаю с первого -> по кругу

* Используется, когда, в принципе, задачу распределения нагрузки можно решить вот.. прям стандартно

![Pasted image 20241027115438](image-storage/Pasted%20image%2020241027115438.png)
## Least Connections
> Новые запросы направляются к серверу или ресурсу с наименьшим текущим количеством активных соединений, что обеспечивает балансировку нагрузки в соответствии с текущей загруженностью.

* Используется, если у сервиса есть какие-то долгие процессы

![Pasted image 20241027115640](image-storage/Pasted%20image%2020241027115640.png)

## Least Response Time
> Новые запросы поступают на сервер, который по объективной оценке имеет наименьшую задержку в обработке запросов и/или имеет наименьшее число активных соединений

* Используется, когда важен быстрый отклик

![Pasted image 20241027120045](image-storage/Pasted%20image%2020241027120045.png)
## Source IP Affinity или IP Hash
> Запросы от одного IP-адреса всегда перенаправляются к одному и тому же серверу или ресурсу, что позволяет обслуживать клиента одним и тем же узлом для последовательности в обработке запросов.

* Удобнее всего использовать при работе с образованием сессий для клиента

![Pasted image 20241027120306](image-storage/Pasted%20image%2020241027120306.png)

## Consistent hashing
> Нагрузка распределяется на основе так называемого **hashring'а**

* Используется для случаев с образованием сессий

IP-адресс серверов хэшируется, IP-адресс запросов извне тоже хэшируется, на основе хэшей составлено кольцо, имеющее некоторый порядок (кто за кем, по часовой, например). 
![Consistent-Hashing](image-storage/Consistent-Hashing.jpg)
На основе этого кольца, например, по часовой стрелке определяется какой запрос на какой сервер улетит. (Node - сервер)
![Mapping-in-the-hashing-(1)](image-storage/Mapping-in-the-hashing-(1).jpg)

## Rendezvous hashing or HRW
> Улучшенная версия consistent hashing. Известная также как **Highest random weight hashing (HRW)**. 

В качестве k будем считать будем считать некоторый shard или запрос. Суть метода заключается в хэширование, условно, конкатенированной пары шарда/запроса и id сервера, далее из этого берётся максимум, таким образом мы определяем куда полетит новый текущий шард k.

![Pasted image 20241027123853](image-storage/Pasted%20image%2020241027123853.png)
## Adaptive Load Balancing
> Нагрузка динамически распределяется на основе актуальной информации о состоянии, производительности или других метриках серверов или ресурсов, что позволяет оптимизировать производительность системы.

* Довольно часто в этом вопросе применяется **Machine Learning** сфера

## Geographical algorithms
> Распределение запросов происходит с учётом географического местоположения источника запроса

![Pasted image 20241027120827](image-storage/Pasted%20image%2020241027120827.png)

## Weighted algorithms
> Распределение запросов происходит с учетом весов, назначенных каждому серверу или ресурсу, что позволяет учитывать их производительность или мощность при назначении нагрузки.
> Это некоторого рода "модификация", применимая поверх для любой из представленных ранее стратегий

![Pasted image 20241027120655](image-storage/Pasted%20image%2020241027120655.png)

# Что делать, если load balancer упал?
## Redundancy
> Масштабировать сервис горизонтально, чтобы если упал 1, то 2-ой бы подменил и забрал на себя всю нагрузку
![Pasted image 20241027124755](image-storage/Pasted%20image%2020241027124755.png)
![Pasted image 20241027124803](image-storage/Pasted%20image%2020241027124803.png)
### metrics and tools
* Health checking
![Pasted image 20241027125133](image-storage/Pasted%20image%2020241027125133.png)
* Auto repair & auto scalling
На основе мониторинга можно предположить, как балансировщик погибает, на основе этого данные или перенаправляются на другой существующий или на новый балансировщик
* DNS Failover
Это технологический механизм, который автоматически обновляет и перенаправляет запросы на другой load balancer