Управление данными достигается за счёт:
* **Eventual consistency** (ожидается конечной результат всех операций), когда не обязательна немедленная согласованность данных
* **Strong consistency** (все операции чтения возвращают наиболее актуальную последнюю запись), подобная согласованность нужна в фин. операциях обычно
* **Partitions** (разделение данных на мелкие управляемые куски), когда различные домены информации могут использоваться независимо друг от друга
# Распределённые транзации
> Очевидно, что они подчинаются ACID принципам...
## 2PC
> 2 Phase Commit - подход, при котором управление транзакцией делится на этап **подготовки/preparation** (просьба всем причастным сервисам "подготовиться") и этап **фиксации/committing** (если хотя бы один сервис отказывается коммитить, то всем сервисам улетает *отказ/rollback*)
* Когда какой-то сервис долго думает над коммитом, то данные и сервисы блокируются
* Многократный опрос всех сервисов затратный...
## Saga
> Подход, при котором транзакция делится на множество мелких этапов или **локальных транзакций**, а также подразумевает, что в случае ошибки производятся **компенсирующие действия**.
* Хранит для этого файлы состояний конфигураций
### Orchestration
> Есть некоторый оркестратор, который по порядку (или параллельно, если возможно) отправляет локальные транзакции сервисам, а потом на основе совокупности всех запросов принимает конечно решение (проводим транзакцию или нет)
* Когда важен порядок операций
* Когда комплексные операции
* Когда централизованное управление сильно помогает в поддержке сервиса
* Когда важна транзакционная согласованность
### Choreography
> Подход, при котором сервисы могут осуществить свою транзакцию и совершить, например, последующий запрос другому сервису, такие сервисы также могут применять компенсирующие действия самостоятельно.
* Когда микросервисы по природе независимы
* Примитивные операции
* Важна масштабируемость
* Довольно удобно использовать в EDA
### Error treat strategies
> Очень часто применяются чуть ли не все скопом
#### Компенсационные транзакции
* Удобно следить за data consistency
* Удобно сохранять промежуточные результаты
* Писать кучу описаний { Do + Undo } человеку тяжко...
* А ещё с этим удвоенным набором транзакций тяжко обеспечивать изоляцию данных и их консистентность
#### Retry
* Для временных ошибок
* Может увеличить нагрузку системы
#### Timeout
* Ошибки не приходится долго ждать, улучшает отклик системы
* Не решает проблемы
#### Circuit breaker / предохранитель
> Если операции слишком частые и понятно, что они не будут успешными, то такие операции блокируются на время
* Разгружает системы от спамма сбоев
* Неправильная установка порогов может привести к тотальным отказам в обслуживании
#### EDA
> Event Driven...
* Лёгкая расширяемость + удобный отклик другими сервисами
* Неудобно отслеживать состояние транзакций
* Настройка EDA всегда тоже требует некоторой надёжности и отдельной настройки
#### Мониторинг и алерты
> **Prometheus**, **Grafana**
* На алерты может реагировать специальная команда (людей)
* А как жить с ложными срабатываниями?
* Настройка отдельная
### Tools
* Long Running Actions for MicroProfile - для длинный транзакций
* Axon - CQRS + Event Sourcing + DDD (Domain Driven...)
* Seata Saga Mode - для длинных транзакций
* Eventuate Tram Sagas - JDBC и JPA используют
* Oracle Database
* Apache Camel Saga