> Микрофронты - концепт микросервисов в мире фронтенда

**Полезно**, когда:
* Несколько команд
* Проект определённо собирается расти
* Важно развёртывание отдельных фронт-фич
**Не стоит** делать, когда:
* Проект небольшой
* Компоненты тесно связаны по смыслу
* Недостаточно ресурсов или навыков команды для такого рода развёрток и управления
* Когда критически важна производительность
**Полезные моменты**:
* Можно масштабировать отдельные части фронта
* Можно легко развёртывать и внедрять новые фичи почти независимо от других
# Basic components
## Модули 
> Некоторые абстракции, реализующие конкретную бизнес-логику
## Слой композиции 
> ... или то, как будут компоноваться эти самые микрофронты для клиента
### Серверная компоновка
> Рендер всей страницы происходит на стороне сервера и отдаётся клиенту
* Есть фреймворки для упрощения: Single SPA, Module Federation
* Специальные механизмы UI фреймворков: React (lazy, Suspence), Vue/Angular (динамический импорт)
* Специальные компоненты: iframes, web components
### Клиентская компоновка
> Клиент запрашивает некоторые данные, ему приходят части фронта, а компануются они все "прям при нём"
### Гибридная компоновка
> Использование обоих предыдущих компоновок... Тут часто бывает BFF
## Маршрутизация
> Выбор маршрута того, какой микрофронт к кому обращается
* **Клиентская** - перемещение между разными частями веб приложения происходит на стороне клиента
* **Серверная** - только сервер решает, какие данные в ответ на запрос пользователя он может отдать
* **Гибридная** - клиентская + Серверная
* **Динамическая** - у микрофронта есть либо свой "роутер", либо есть некоторый оркестратор, который и решает в зависимости от запросов пользователя, куда обращаться
## Коммуникационный слой
> Отвечающий за коммуникацию микрофронтедов и остальной части приложения (всякого рода api бэка и т.п.)
### API'ful
>Взаимодействие микрофронтов осуществляется строго через бэкенд.
* Когда приложение простое
* Когда бэк прям обязан быть центром всей логики
* Когда нужна высокая масштабируемость (и независимость микрофронтов)
### Pub/Sub
>Как и паттерн проектирования **publisher - subscriber** (или ещё называют Observer), микрофронты просто подписываются на некоторую **шину сообщений** для получения данных, а кто-то кидает данные в эту шину сообщений (с некоторым идентификатором, конечно же)
* Предпочтительна изолированность модулей, но при этом они всё ещё могут "общаться"
* Realtime отображение
### Global state library
> Иногда и **shared state**. Данные лежат на некоторой глобальной библиотеке, модули обновляют и смотрят все данные именно через неё.
> Обычно такими библиотеками в JS выступают Redux, MobX, Context API.
> Также допустима реализация Observable State, где какой-то модуль может просто подписаться на обновления некоторый состояний.

* Когда некоторые модули связаны
* Нужно управлять сложными данными
* Важно поддерживать одно состояние на несколько модулей
# BFF
> **Backend for Frontend** - означает, что для каждого микрофронта есть свой отдельный API/сервер, который и отдаёт микрофронту компоненты, актуальные только для него

Есть такая ситуация:
![](resources/image-storage/Untitled_1718989634.png)
* Разработчикам Корзины надо следить на несколькими бэк сервисами. 
* Это сложно + ему придётся усложнять код по мере изменения требований. 
Можно сделать так:
![](resources/image-storage/Untitled_1718989761.png)
* Также можно будет добавить прослойку защиты данные на BFF уровне
* Кол-во обращений к бэкенду тоже падает
* Можно реализовать кэширование на уровне BFF
* Важно подобрать тех стэк
* Важно внедрить системы мониторинга, логирования и обработки ошибок
# Стратегии проектирования
## Вертикальная нарезка 
>Сконцентрирована на том, чтобы построить микрофронт над каждой отдельной бизнес-логикой
* Важно понимать, что домены бизнес-логика не должна быть взаимозависимой
* Позволяет командам независимо друг от друга легко внедрять обновления своих доменов
* Часто самых стандартный вариант для огромных проектов со сложным UI
### Domain Driven Design
> **(DDD) Domain Driven Design** - так называется стратегии, где всё отталкивается от "доменов ответственности", они же равносильны сферам бизнес-логики.
## Автономные команды
>Каждая команда выбирает какой тех стэк хочет использовать для своих задач
* Командам проще работать в знакомых себе сферах и внедрять что-то новое
* Важны преимущественные специфики конкретных тех-стэков
* Некоторые проблемы могут стать общими для разных команд, что замедлит разработку
## Изоляция
>Сконцентрирована на изоляции зависимостей компонентов. При этом допускаются некоторые общие зависимости, это решается некоторыми утилитами
* Позволяет не привязываться к версиям других микрофронтов
* Простое обновление конкретных компонентов
* Общие компоненты придётся включать в разные фронты, что повлияет на размер пакета
### Module Federation
> Подход, позволяющий объединить несколько модулей из разных тех стеков в одно
# Integration methods
## Build time
> Все пакетные зависимости и ресурсы помещают в один контейнер
* Получается большой пакет
* Нужно следить за версионной совместимостью
* Пересборка всего пакеты в случае чего
* Тесные связи
* Положительно сказывается на SEO и первичной загрузке сайта
* Примитивное развёртывание
## Run time
> Выстраивается единный API всех микрофронтов на стороне клиента
* Нужно продумать маршрутизацию
* Нужно подумать над контролем состояний
* Гибкое масштабирование
* Лёгкая интеграция модулей или их обновлений
# Migrate plan
![](resources/image-storage/Pasted%20image%2020250322155928.png)
# Tools
> Их много, но тут будут только основные/популярные
## Webpack Module Federation
>Это пакетный модуль JS
* Настраивается в `webpack.config.js`
* Основным отличием является возможность share'ить некоторые зависимости между разными модулями/микрофронтами
* Поддерживает *lazy loading* (когда данные приходят только по запросу)

Есть компоненты (связаны как `<1 host> to <many remote modules>`):
* Host - основное приложение. которое запрашивается модули
* Remote module - микрофронт, предоставляющий себя или часть своего фукнционала хосту
## Single SPA
>Тоже JS пакетный модуль
* Настраивается в `root-config.js`
* Основным отличием является то, что микрофронты настолько изолированы, что они могут использовать абсолютно разные технологии и фреймворки, они потом монтируются в основное приложение
# Other stuff
* **(SaaS) Software as a Service** - это некоторое ПО, которое работает как сервис с клиентом через интернет. (Ближайшие примеры: почта, облачные заметки и т.п.)
* **(SEO) Search engine optimisation** - это некоторый механизм поискового движка, которые каким-то образом по содержимому страницы оценивает приоритет отображения сайта как можно выше.
* **PoC (Proof of Concept)** - некоторый ресёрч и доказательство, что какой-то концепт работает и может быть использован
* **MVP (Minimum Viable Product)** - продукт с некоторым минимальным функционалом, достаточным, чтобы выйти на рынок
* **SPA (Single Page Application)** - у сервиса/приложения всего 1 страница
* **CMS (Content Management System)** - системы управления контентом.. это вид сайта
* **SSR** - Server Side Rendering
* **PWA (Progressive Web App)** - технология преобразования веб-страницы чуть ли не в полнофункциональное приложение. Например сервисы карт могут продолжать работать без подключения к интернету.