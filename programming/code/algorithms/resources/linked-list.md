# Linked list
> Каждый элемент (Node) содержит значение и указатель на следующую ноду.
> * Поиск по такому листу всегда O(N) -> т.к. надо по каждому элементу пройтись
> * Удаление и вставка первого элемента O(1) -> т.к. достаточно перезаписать значение head-node'ы.
> * Удаление и вставка элемента в остальных случаях O(n) -> т.к. до элемента надо сначала дойти (по факту это поиск)

```cpp
struct Node {
  T    value;    // Текущее значение
  T    *next;    // "Указание" на следующее

  Node()
    : value()
    , next(nullptr)
  { }

  Node(value, next = nullptr)
    : value (value)
    , next(next)
  { }
};
```

* Есть также `двунаправленный список`, который содержит "указание" не предыдущую ноду.

## Deque
> Двухсвязный список, где элементами могут являться уже последовательности данных.
> Т.е. где-то лежит в памяти вектор на 10 элементов, последний элемент такого вектора ссылается на вектор в другом месте памяти на 60 элементов, у которого последний элемент тоже ссылается на следующий кусок данных и т.п.

## Queue
> Двухсвязный список, работающий по принципу FIFO (First in first out).

## Stack 
> Двухсвязный список, работающий по принципу LIFO (Last in first out).

### Tips
* Когда использовать однонаправленный список? - В явном виде... никогда? Очередь и стэк реализованы с помощью это списка, если нужна какая-то необычная функциональность типа circular buffer (https://en.wikipedia.org/wiki/Circular_buffer), то можно модифицировать linked list
* Когда использовать двунаправленный список? - Одна из явных ассоциаций для применения это страница в бразуере и функциональность <вперёд - назад>. Т.е. работа только с ближайшими значениями от некоторой позиции.
* Когда использовать дек? - Когда нужен вектор, в котором помещение новых данных не вызывает реаллокацию (перекопирование) уже записанных данных.