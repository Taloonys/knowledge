# Зачем это вообще?
> Правильнее всего увидеть сначала какую-то ёмкую проблему и довольно короткое лаконичное решение к ней, чтобы понять зачем это секция на собеседованиях вообще.  
* Многие уже устоявшиеся концепты/механизмы в системе нельзя переписать, а в таске указана некоторая новая фича, которая не особо подходит под данную систему, да, где-то частично проблема архитектуры, однако не часто можно "сесть на все стулья одновременно".
* Все принципы load-balancer'ов пошли как раз из базовой (ну или не только) логики алгоритмики и математики, тот же hash-ring 99.9% людей почти никогда не встретят в своих задачах или вообще не знают, что это такое. А оно есть и кое-где ощутимо прибавляет в performance. То же самое касается и БД и т.п.
* Примитивные задачи могут отнять много времени, но определённые концепты и структуры данных позволяют минимизировать время решения таких задач. Преобразование сложных ветвлений в довольно короткие методы с обращением к специальным структурам данных - отдельный вид искусства чистого кода, к тому же они позволяют иметь довольно обширный контроль над данными.
  
# Оглавление
* [Big O notation](big-o-notation.md)
* [Sorting methods](sorting.md)
* [Data structures](data-structures.md)
* [Common patterns](common-patterns.md)

# Математика
> Математика довольно часто помогает сократить машинные вычисления. Например... Проблема: некоторая задача сводится к пробежке по вектору несколько раз почти в любом случае. Это затратно. Решение: сложить некоторые диапазоны вектора или просто высмотреть последовательность + сделать один единственный рассчёт.

** ЗДЕСЬ ПОТОМ БУДЕТ СССЫЛКА НА РАЗДЕЛ С МАТ. ТЕР.ВЕР. и т.п. **

## Комбинаторика
> https://practicum.yandex.ru/blog/perestanovki-razmescheniya-sochetaniya-v-analize-dannyh/

### Важное пояснение
* Различие между `размещениями` и `сочетаниями` заключается в **порядке**.
* **Под порядком подразумевается**, что для `размещения` { А, B } и { B, A } - это **2 разных случая**, а для `сочетания` (которому **не важен порядок**) это **один и тот же случай**.
* Поэтому в формуле для сочетания в знаменателе дроби есть дополнительно k!, т.е. таких случаев меньше, чем с расстановкой.

## Фибоначчи
> https://habr.com/ru/articles/261159/
> Возможный случай применения: когда случай или значение текущего элемента в некоторой степени "зависит" от вычисления двух предыдущих.
* Задачка с лестницей (leetcode №70): найти кол-во возможных путей до n-ой ступеньки, если можно шагать только по одной (+1) либо через одну (+2). "Удобный вариант" решения:
```cpp
    int climbStairs(int n) {
        //
        // до 1 ступеньки можно шагнуть только путём +1
        // до 2 ступеньки 2 путями: +1+1 и +2
        // чтобы шагнуть до n ступеньки, достаточно вспомнить, как мы шагали до n-1 ступеньки и до n-2 ступеньки и сложить
        //
        std::vector fib_vec(n+1);
        fib_vec[0] = 1;             // это значение для удобства алгоритма, чтобы могли получить путь до 2 ступеньки
        fib_vec[1] = 1;             // кол-во путей до 1 ступеньки

        for (int i = 2; i <= n; i++) {
            //
            // Чисто формула Фибоначчи
            //
            fib_vec[i] = fib_vec[i-1] + fib_vic[i-2];
        }

        return fib_vec[n];
    }
```
