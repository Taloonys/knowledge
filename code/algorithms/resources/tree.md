
> Деревом называют структуру данных, которая представляет собой совокупность элементов, а также отношений между этими элементами, что вместе образует иерархическую древовидную структуру. 

Как уже было указано выше, есть 3 типа сложности операций: вставка, удаление, поиск. Связный список справляется со поиском O(N), что довольно долго. Так же сортировка будет занимать O(N), т.к. каждый раз надо будет переставлять множество элементов. Для этой задачи хорошо подходят деревья.

![Untitled](image-storage/Untitled%205%201.png)

* **Корень** - самый “верхний” элемент дерева
* **Ветки** - связи между элементами
* **Узлы или Node'ы** - все "промежуточные" элементы дерева 
* **Листья** - самые “нижние” элементы
* Можно называть все элементы **нодами** и не страдать =)

## Бинарное (двоичное) дерево
> Дерево, где у каждой ноды есть не более 2 дочерних нод.

![Untitled](image-storage/Untitled%206%201.png)

![Untitled](image-storage/Untitled%207%201.png)

## Бинарное (двоичное) дерево поиска
> Бинарное дерево, где на одной стороне дочерние ноды большие по значению, а на другой - меньшие.

![Untitled](image-storage/Untitled%208%201.png)

Для проверки операций вставки или удаления существуют методы обхода дерева:
- Симметричный обход - выводится самый левый ребёнок, родитель, самый правый ребёнок, родитель.
- Обратных обход дерева - сначала выводится левый ребёнок, затем правый ребёнок, а затем так же с родителями.

![Untitled](image-storage/Untitled%209%201.png)

![Untitled](image-storage/Untitled%2010%201.png)

## Балансировка
> Дерево будет являться **сбалансированным**, если **разница высот между дочерними узлами по модулю меньше или равна единице**. 
## AVL дерево
> В бинарном дереве поиска можно заметить, что процесс поиска самого максимального или самого минимального значения (самый правый нижний и левый элементы соответственно) будет иметь алгоритмическую сложность O(n). Для решения такой проблемы придумали AVL деревья, отличием которых от бинарного дерева поиска является **балансировка дерева** во время добавления или удаления узла. Такое дерево обладает **логорифмической сложностью на всех операциях**.

![Untitled](image-storage/Untitled%2011.png)

В то время как **высотой узла** будет являться самый длинный путь от его ребёнка до листа, включая самого ребёнка и лист.
![Untitled](image-storage/Untitled%2012.png)


Если разница составляет отрицательное число (вычитаем высоту левого узла из правого), то такое дерево будет  называться перегруженным влево, если положительным - перегруженным вправо.

![Untitled](image-storage/Untitled%2013.png)

Механизмом балансировки деревьев являются **повороты вправо** и **влево** относительно некоторого узла.

![Untitled](image-storage/Untitled%2014.png)

Также существуют правый-левый повороты и левый-правый, для того, чтобы понять нужны ли они нам - необходимо проводить проверку балансировки и дочерних узлов.

![Untitled](image-storage/Untitled%2015.png)

## Красно-чёрное дерево

> AVL дерево подразумевает огромное кол-во операций расчёта балансировки дерева помимо самих операций поиска, вставки и удаления. Для этого придумали красно-чёрное дерево, которое всегда остаётся сбалансированным. **Каждый узел дерева** теперь имеет **красный** или **чёрный** цвет.

**Каждый лист дерева** - **null-чёрный узел**. **Корень** дерева **всегда чёрный узел**. У **красного узла оба ребёнка** должны быть **чёрными**. Так же вводится наличие такого параметра как **чёрная высота** - кол-во чёрных узлов на **любом пути** от узла до null-листа (null-лист включительно), “любой” здесь означает, что такая высота должна быть везде одинаковой.

![Untitled](image-storage/Untitled%2016.png)

Вставка красных элементов более “безопасная”, т.к. не ломает логику с чёрной высотой. Ниже представлены возможные случаи вставки

![Untitled](image-storage/Untitled%2017.png)

---

# Сравнение сложности операций массивов, списков и деревьев.

[https://habr.com/ru/articles/188010/](https://habr.com/ru/articles/188010/)

![Untitled](image-storage/Untitled%2018.png)
