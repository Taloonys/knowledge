> Паттерн нацелен на создание одного единственного уникального объекта в памяти, что может жить на протяжении всего цикла работы программы, к нему так же возможно обращение откуда угодно.

## Subjects:

Субъект здесь всего один, сам одиночный объект. Но так же можно написать через generic механизмы для обёртки в синглтон других классов. **Но есть ключевые моменты**:

- **Singleton class**
    - Сам класс, который будет существовать в единственном экземпляре на протяжении всего времени жизни программы, это может быть реализовано как угодно, в зависимости от ЯП, в С++ самое стандартное и частое - static. Такой класс должен иметь приватный конструктор и деструктор, чтобы никто извне не имел ответственности за его создание или удаление.
- **Static Member Variable**
    - Должна быть приватная статик переменная, которая и является ядром синглтона
- **Static Method (instance or getInstance)**
    - Должен существовать статический метод, по которому можно обращаться к тому самому "ядру" синглтона. "Если объекта нет, создай его и позволь обратиться к нему, если есть - то надо обращаться к тому, что есть"
- **Disable Copy semantics**
    - Также запрещать копирование (исходя из идоимы паттерна о единственности).
    Примитивный вариант реализации:

```cpp
class Singleton {
	static Singleton* instance;
	// static Singleton* Singleton::instance = nullptr;
public:
//
// На самом деле один этот метод описывает весь паттерн
//
	static Singleton* getInstance() 
	{
		if (!instance) instance = new Singleton();
		return *instance;
	};

	void doSth() const {
		std::cout << "Singleton do sth" << std::endl;
	};

	Singleton(const Singleton &) = delete; // очевидно, что "единственный экземпляр"
	Singleton & operator=(const Singleton &) = delete; // .. нельзя копировать
private:
	Singleton() {
		std::cout << "Singleton instance constructed" << std::endl;
	};

	~Singleton() noexcept {
		std::cout << "Singleton died" << std::endl;
	};
}

// на первом вызове getInstance проиcходит создание instance, можно сделать где угодно

int main()
{
	auto& singleton = Singleton::getInstance(); // это можно вызвать где угодно, достаточно лишь include

	singleton.someOperation();

	return 0;
}

```

А так он может выглядеть как угодно... Но стоит быть очень осторожным с обращением к синглтону из разных потоков, это надо обязательно учитывать при его написании.. поэтому использование smart_ptr здесь становится ещё опаснее, однако смысла в этом нет, ибо никто им не должен владеть.
Самый полезный пример для ассоциации - меню настроек в игре. Некоторый обособленный функционал, к которому можно обратиться когда и где угодно

*Не стоит перегружать функционально конструирование синглтон объекта*

## Нюансы

- Возможна зависимость многих классов от такого объекта
- Можно проглядеть, когда синглтон случайно жёстко связывает разного рода объекты
- Сложно изолировать для теста объект, который ссылается на синглтон
- Немного с подвохом наследование от такого объекта
- Ограниченное внедрение зависимостей

## Use-cases

- Loggers
- Менеджер подключений к БД
- Менеджер конфигов
- Система кэширования
- Менеджер потоков
- Аутентификация юзера
- Машина состояний
- Менеджер подключённых устройств
- Менеджер выделения и удаления ресурсов
- HTTP-request менеджер
- Game-scoreboard
- Менеджер событий
- Менеджер очередей