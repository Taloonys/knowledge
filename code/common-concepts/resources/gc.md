> Garbage collector - это специальный механизм некоторых ЯП, который самостоятельно следит за временем жизни объектов.

# Types
* Ref-counter based (например Python)
* Trace-based (например Golang)
# Possible logics
- Вызов его **по timeout’у**
    * Он работает не прям постоянно, он вызывается каждый раз через какое-то время (вроде даже в отдельном потоке), вызывается, спрашивается <кто есть или кто больше не нужен>, удаляются ненужные объекты и он засыпает
- **Счётчик того, сколько не использовался объект**
    Ему нужно понимать как-то, используется ли вообще объект или нет, если не используется, то встаёт вопрос о его удалении
- **Необходимость компилятору “доказать”,** что больше объект не будет использоваться
	- Ему нужно как-то доказать, что объект можно удалять, т.к. он больше не будет нужен, для этого внутри garbage collector’а реализована структура процесса исполнения. По которой и происходит доказательство.  
		* В плюсах этот граф исполнения слегка сложный, из-за чего в нём невозможно алгоритмически решить задачу доказательства → поэтому в плюсах нет garbage collector’а. (Он как-то на бумаге был с 11 по 17-20 стандарты, но был удалён)
		* В питоне этот граф сделан так, что в строку можно прям помещать название переменной, а информация под неё соответствующе подцепиться. 
		* В Rust это дерево вообще.. что даже в межпоточке компилятор может выдавать ошибки аж на этапе сборки. 